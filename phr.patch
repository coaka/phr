diff -Naur ns-allinone-2.35_orig/ns-2.35/common/packet.h ns-allinone-2.35/ns-2.35/common/packet.h
--- ns-allinone-2.35_orig/ns-2.35/common/packet.h	2020-07-24 19:47:50.905828092 +0300
+++ ns-allinone-2.35/ns-2.35/common/packet.h	2020-07-24 15:07:58.805298659 +0300
@@ -59,6 +59,7 @@
 #define HDR_LL(p)       (hdr_ll::access(p))
 #define HDR_HDLC(p)     ((hdr_hdlc *)hdr_ll::access(p))
 #define HDR_IP(p)       (hdr_ip::access(p))
+#define HDR PHR(p)      (hdr phr::access(p))
 #define HDR_RTP(p)      (hdr_rtp::access(p))
 #define HDR_TCP(p)      (hdr_tcp::access(p))
 #define HDR_SCTP(p)     (hdr_sctp::access(p))
@@ -199,8 +200,10 @@
         // M-DART packets
 static const packet_t PT_MDART = 72;
 	
-        // insert new packet types here
-static packet_t       PT_NTYPE = 73; // This MUST be the LAST one
+// PHR packet        
+static const packet_t PT_PHR = 73;
+// insert new packet types here
+static packet_t       PT_NTYPE = 74; // This MUST be the LAST one
 
 enum packetClass
 {
@@ -402,6 +405,8 @@
 		
 		// AOMDV patch
 		name_[PT_AOMDV]= "AOMDV";
+		// PHR
+		name_[PT_PHR]="PHR";
 
 		// PUMA
 		name_[PT_PUMA]="PUMA";
diff -Naur ns-allinone-2.35_orig/ns-2.35/config.log ns-allinone-2.35/ns-2.35/config.log
--- ns-allinone-2.35_orig/ns-2.35/config.log	2020-07-24 19:47:50.749824686 +0300
+++ ns-allinone-2.35/ns-2.35/config.log	2020-07-24 18:50:22.090920026 +0300
@@ -27,7 +27,7 @@
 /usr/bin/oslevel       = unknown
 /bin/universe          = unknown
 
-PATH: /home/coaka/Documents/ns-original/ns-allinone-2.35/bin
+PATH: /home/coaka/Downloads/ns-allinone-2.35/bin
 PATH: /home/coaka/bin
 PATH: /home/coaka/.local/bin
 PATH: /usr/local/sbin
@@ -804,8 +804,8 @@
 configure:7959: result: yes
 configure:7959: checking for fesetprecision
 configure:7959: gcc-4.8 -o conftest -g -O2   conftest.c -lm  >&5
-/tmp/ccDVoKMc.o: In function `main':
-/home/coaka/Documents/ns-original/ns-allinone-2.35/ns-2.35/conftest.c:83: undefined reference to `fesetprecision'
+/tmp/ccPk2ZlL.o: In function `main':
+/home/coaka/Downloads/ns-allinone-2.35/ns-2.35/conftest.c:83: undefined reference to `fesetprecision'
 collect2: error: ld returned 1 exit status
 configure:7959: $? = 1
 configure: failed program was:
@@ -1893,8 +1893,8 @@
 configure:8901: result: found
 configure:8915: checking for addr2ascii
 configure:8915: gcc-4.8 -o conftest -g -O2   -Wl,-export-dynamic conftest.c -lm  >&5
-/tmp/ccXsrzQe.o: In function `main':
-/home/coaka/Documents/ns-original/ns-allinone-2.35/ns-2.35/conftest.c:94: undefined reference to `addr2ascii'
+/tmp/ccddOzdX.o: In function `main':
+/home/coaka/Downloads/ns-allinone-2.35/ns-2.35/conftest.c:94: undefined reference to `addr2ascii'
 collect2: error: ld returned 1 exit status
 configure:8915: $? = 1
 configure: failed program was:
@@ -2114,14 +2114,14 @@
 
 on coaka
 
-config.status:927: creating Makefile
-config.status:927: creating tcl/lib/ns-autoconf.tcl
-config.status:927: creating indep-utils/webtrace-conv/ucb/Makefile
-config.status:927: creating indep-utils/webtrace-conv/dec/Makefile
-config.status:927: creating indep-utils/webtrace-conv/nlanr/Makefile
-config.status:927: creating indep-utils/webtrace-conv/epa/Makefile
-config.status:927: creating indep-utils/cmu-scen-gen/setdest/Makefile
-config.status:927: creating autoconf.h
+config.status:926: creating Makefile
+config.status:926: creating tcl/lib/ns-autoconf.tcl
+config.status:926: creating indep-utils/webtrace-conv/ucb/Makefile
+config.status:926: creating indep-utils/webtrace-conv/dec/Makefile
+config.status:926: creating indep-utils/webtrace-conv/nlanr/Makefile
+config.status:926: creating indep-utils/webtrace-conv/epa/Makefile
+config.status:926: creating indep-utils/cmu-scen-gen/setdest/Makefile
+config.status:926: creating autoconf.h
 
 ## ---------------- ##
 ## Cache variables. ##
@@ -2271,16 +2271,16 @@
 V_DEFINES='-DHAVE_LIBTCLCL -DHAVE_TCLCL_H -DHAVE_LIBOTCL1_14 -DHAVE_OTCL_H -DHAVE_LIBTK8_5 -DHAVE_TK_H -DHAVE_LIBTCL8_5 -DHAVE_TCLINT_H -DHAVE_TCL_H '
 V_IMPORT_LIBS=''
 V_INCLUDE=''
-V_INCLUDES='-I/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/usr/include/pcap'
+V_INCLUDES='-I/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/usr/include/pcap'
 V_INCLUDE_X11=''
 V_LIB=' -lnsl -ldl'
 V_LIBRARY_TCL='../lib/tcl8.5'
 V_LIBRARY_TK='../lib/tk8.5'
-V_LIBS='-L/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -ltclcl -L/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -lotcl -L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltk8.5 -L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltcl8.5'
-V_LIB_OTCL='-L/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -lotcl'
-V_LIB_TCL='-L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltcl8.5'
-V_LIB_TCLCL='-L/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -ltclcl'
-V_LIB_TK='-L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltk8.5'
+V_LIBS='-L/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -ltclcl -L/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -lotcl -L/home/coaka/Downloads/ns-allinone-2.35/lib -ltk8.5 -L/home/coaka/Downloads/ns-allinone-2.35/lib -ltcl8.5'
+V_LIB_OTCL='-L/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -lotcl'
+V_LIB_TCL='-L/home/coaka/Downloads/ns-allinone-2.35/lib -ltcl8.5'
+V_LIB_TCLCL='-L/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -ltclcl'
+V_LIB_TK='-L/home/coaka/Downloads/ns-allinone-2.35/lib -ltk8.5'
 V_LIB_X11='-lXext -lX11'
 V_LSSCRIPT=''
 V_NS_TCL_LIB_STL='$(NS_TCL_LIB_STL)'
@@ -2295,7 +2295,7 @@
 V_TAR_EXTRA=''
 V_TAR_TARGET='linux-gnu'
 V_TCL2CPP='../tclcl-1.20/tcl2c++'
-V_TCLSH='/home/coaka/Documents/ns-original/ns-allinone-2.35/bin/tclsh8.5'
+V_TCLSH='/home/coaka/Downloads/ns-allinone-2.35/bin/tclsh8.5'
 V_TCL_LIBRARY_FILES='$(TCL_BASE_LIBRARY_FILES) ../lib/tcl8.5/http1.0/http.tcl'
 V_TKDOSNAMES='$(LIBRARY_TK)/optMenu.tcl $(LIBRARY_TK)/scrlbar.tcl'
 ac_ct_CC='gcc-4.8'
diff -Naur ns-allinone-2.35_orig/ns-2.35/config.status ns-allinone-2.35/ns-2.35/config.status
--- ns-allinone-2.35_orig/ns-2.35/config.status	2020-07-24 19:47:50.897827918 +0300
+++ ns-allinone-2.35/ns-2.35/config.status	2020-07-24 18:50:21.754905181 +0300
@@ -445,7 +445,7 @@
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
-ac_pwd='/home/coaka/Documents/ns-original/ns-allinone-2.35/ns-2.35'
+ac_pwd='/home/coaka/Downloads/ns-allinone-2.35/ns-2.35'
 srcdir='.'
 INSTALL='/usr/bin/install -c'
 test -n "$AWK" || AWK=awk
@@ -641,18 +641,17 @@
 S["V_TAR_EXTRA"]=""
 S["V_CCOPT"]=""
 S["V_ALL"]=""
-S["V_LIB_TK"]="-L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltk8.5"
-S["V_LIB_TCL"]="-L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltcl8.5"
-S["V_LIB_OTCL"]="-L/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -lotcl"
-S["V_LIB_TCLCL"]="-L/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -ltclcl"
+S["V_LIB_TK"]="-L/home/coaka/Downloads/ns-allinone-2.35/lib -ltk8.5"
+S["V_LIB_TCL"]="-L/home/coaka/Downloads/ns-allinone-2.35/lib -ltcl8.5"
+S["V_LIB_OTCL"]="-L/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -lotcl"
+S["V_LIB_TCLCL"]="-L/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -ltclcl"
 S["V_TAR_TARGET"]="linux-gnu"
 S["V_STATIC"]=""
 S["V_DEFINES"]="-DHAVE_LIBTCLCL -DHAVE_TCLCL_H -DHAVE_LIBOTCL1_14 -DHAVE_OTCL_H -DHAVE_LIBTK8_5 -DHAVE_TK_H -DHAVE_LIBTCL8_5 -DHAVE_TCLINT_H -DHAVE_TCL_H "
-S["V_LIBS"]="-L/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -ltclcl -L/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -lotcl -L/hom"\
-"e/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltk8.5 -L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltcl8.5"
-S["V_INCLUDES"]="-I/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Documen"\
-"ts/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone"\
-"-2.35/include -I/usr/include/pcap"
+S["V_LIBS"]="-L/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -ltclcl -L/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -lotcl -L/home/coaka/Downloads/ns-all"\
+"inone-2.35/lib -ltk8.5 -L/home/coaka/Downloads/ns-allinone-2.35/lib -ltcl8.5"
+S["V_INCLUDES"]="-I/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Downloads/ns-allinone-2.35/incl"\
+"ude -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/usr/include/pcap"
 S["build_nse"]=""
 S["NSLIB"]="libns.so"
 S["PKG_SHLIB_CFLAGS"]=""
@@ -671,7 +670,7 @@
 S["V_LIBRARY_TK"]="../lib/tk8.5"
 S["V_TKDOSNAMES"]="$(LIBRARY_TK)/optMenu.tcl $(LIBRARY_TK)/scrlbar.tcl"
 S["V_LIBRARY_TCL"]="../lib/tcl8.5"
-S["V_TCLSH"]="/home/coaka/Documents/ns-original/ns-allinone-2.35/bin/tclsh8.5"
+S["V_TCLSH"]="/home/coaka/Downloads/ns-allinone-2.35/bin/tclsh8.5"
 S["V_TCL_LIBRARY_FILES"]="$(TCL_BASE_LIBRARY_FILES) ../lib/tcl8.5/http1.0/http.tcl"
 S["CPP_NAMESPACE"]="std"
 S["ac_ct_CXX"]=""
diff -Naur ns-allinone-2.35_orig/ns-2.35/indep-utils/webtrace-conv/dec/Makefile ns-allinone-2.35/ns-2.35/indep-utils/webtrace-conv/dec/Makefile
--- ns-allinone-2.35_orig/ns-2.35/indep-utils/webtrace-conv/dec/Makefile	2020-07-24 19:47:50.897827918 +0300
+++ ns-allinone-2.35/ns-2.35/indep-utils/webtrace-conv/dec/Makefile	2020-07-24 18:50:21.938913315 +0300
@@ -52,10 +52,10 @@
 BINDEST = /usr/local/bin
 
 CC = g++-4.8
-INCLUDE = -I. -I/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/usr/include/pcap
+INCLUDE = -I. -I/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/usr/include/pcap
 CFLAGS =  -DCPP_NAMESPACE=std
 LDFLAGS = 
-LIBS = -L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltcl8.5  -lnsl -ldl -lm 
+LIBS = -L/home/coaka/Downloads/ns-allinone-2.35/lib -ltcl8.5  -lnsl -ldl -lm 
 INSTALL = /usr/bin/install -c
 
 SRC = proxytrace.cc formsquid.cc formtxt.cc my-endian.cc \
diff -Naur ns-allinone-2.35_orig/ns-2.35/indep-utils/webtrace-conv/epa/Makefile ns-allinone-2.35/ns-2.35/indep-utils/webtrace-conv/epa/Makefile
--- ns-allinone-2.35_orig/ns-2.35/indep-utils/webtrace-conv/epa/Makefile	2020-07-24 19:47:50.901828005 +0300
+++ ns-allinone-2.35/ns-2.35/indep-utils/webtrace-conv/epa/Makefile	2020-07-24 18:50:21.994915790 +0300
@@ -49,10 +49,10 @@
 CC = g++-4.8
 MKDEP	= ../../../conf/mkdep
 
-INCLUDE = -I. -I/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/usr/include/pcap
+INCLUDE = -I. -I/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/usr/include/pcap
 CFLAGS =  -DCPP_NAMESPACE=std
 LDFLAGS = 
-LIBS = -L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltcl8.5  -lnsl -ldl -lm 
+LIBS = -L/home/coaka/Downloads/ns-allinone-2.35/lib -ltcl8.5  -lnsl -ldl -lm 
 INSTALL = /usr/bin/install -c
 
 SRC = tr-stat.cc
diff -Naur ns-allinone-2.35_orig/ns-2.35/indep-utils/webtrace-conv/nlanr/Makefile ns-allinone-2.35/ns-2.35/indep-utils/webtrace-conv/nlanr/Makefile
--- ns-allinone-2.35_orig/ns-2.35/indep-utils/webtrace-conv/nlanr/Makefile	2020-07-24 19:47:50.897827918 +0300
+++ ns-allinone-2.35/ns-2.35/indep-utils/webtrace-conv/nlanr/Makefile	2020-07-24 18:50:21.966914552 +0300
@@ -49,10 +49,10 @@
 BINDEST = /usr/local/bin
 
 CC = g++-4.8
-INCLUDE = -I. -I../../.. -I/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/usr/include/pcap
+INCLUDE = -I. -I../../.. -I/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/usr/include/pcap
 CFLAGS =  -DCPP_NAMESPACE=std
 LDFLAGS = 
-LIBS = -L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltcl8.5  -lnsl -ldl -lm 
+LIBS = -L/home/coaka/Downloads/ns-allinone-2.35/lib -ltcl8.5  -lnsl -ldl -lm 
 INSTALL = /usr/bin/install -c
 
 SRC = tr-stat.cc logparse.cc
diff -Naur ns-allinone-2.35_orig/ns-2.35/indep-utils/webtrace-conv/ucb/Makefile ns-allinone-2.35/ns-2.35/indep-utils/webtrace-conv/ucb/Makefile
--- ns-allinone-2.35_orig/ns-2.35/indep-utils/webtrace-conv/ucb/Makefile	2020-07-24 19:47:50.901828005 +0300
+++ ns-allinone-2.35/ns-2.35/indep-utils/webtrace-conv/ucb/Makefile	2020-07-24 18:50:21.906911900 +0300
@@ -27,10 +27,10 @@
 CC = g++-4.8
 MKDEP	= ../../../conf/mkdep
 
-INCLUDE = -I. -I/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/usr/include/pcap
+INCLUDE = -I. -I/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/usr/include/pcap
 CFLAGS =  -DCPP_NAMESPACE=std
 LDFLAGS = 
-LIBS = -L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltcl8.5  -lnsl -ldl -lm 
+LIBS = -L/home/coaka/Downloads/ns-allinone-2.35/lib -ltcl8.5  -lnsl -ldl -lm 
 INSTALL = /usr/bin/install -c
 
 SRC = tr-stat.cc logparse.cc utils.cc
diff -Naur ns-allinone-2.35_orig/ns-2.35/Makefile ns-allinone-2.35/ns-2.35/Makefile
--- ns-allinone-2.35_orig/ns-2.35/Makefile	2020-07-24 19:47:50.905828092 +0300
+++ ns-allinone-2.35/ns-2.35/Makefile	2020-07-24 18:50:21.842909070 +0300
@@ -38,7 +38,7 @@
 LINK	= $(CPP)
 LINK_SHLIB = gcc-4.8 -shared
 MKDEP	= ./conf/mkdep
-TCLSH	= /home/coaka/Documents/ns-original/ns-allinone-2.35/bin/tclsh8.5
+TCLSH	= /home/coaka/Downloads/ns-allinone-2.35/bin/tclsh8.5
 TCL2C	= ../tclcl-1.20/tcl2c++
 AR	= ar rc $(BLANK)
 
@@ -64,7 +64,7 @@
 INCLUDES = \
 	-I.  \
 	-I. \
-	-I/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/home/coaka/Documents/ns-original/ns-allinone-2.35/include -I/usr/include/pcap \
+	-I/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -I/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/home/coaka/Downloads/ns-allinone-2.35/include -I/usr/include/pcap \
 	-I./tcp -I./sctp -I./common -I./link -I./queue \
 	-I./adc -I./apps -I./mac -I./mobile -I./trace \
 	-I./routing -I./tools -I./classifier -I./mcast \
@@ -76,7 +76,7 @@
 
 
 LIB	= \
-	-L/home/coaka/Documents/ns-original/ns-allinone-2.35/tclcl-1.20 -ltclcl -L/home/coaka/Documents/ns-original/ns-allinone-2.35/otcl-1.14 -lotcl -L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltk8.5 -L/home/coaka/Documents/ns-original/ns-allinone-2.35/lib -ltcl8.5 \
+	-L/home/coaka/Downloads/ns-allinone-2.35/tclcl-1.20 -ltclcl -L/home/coaka/Downloads/ns-allinone-2.35/otcl-1.14 -lotcl -L/home/coaka/Downloads/ns-allinone-2.35/lib -ltk8.5 -L/home/coaka/Downloads/ns-allinone-2.35/lib -ltcl8.5 \
 	-lXext -lX11 \
 	 -lnsl -ldl \
 	-lm -lm 
@@ -278,6 +278,7 @@
 	aomdv/aomdv_logs.o aomdv/aomdv.o \
 	aomdv/aomdv_rtable.o aomdv/aomdv_rqueue.o \
 	puma/puma.o \
+	phr/phr.o \
 	mdart/mdart_adp.o mdart/mdart_dht.o mdart/mdart_ndp.o \
 	mdart/mdart_neighbor.o mdart/mdart_queue.o mdart/mdart_table.o \
 	mdart/mdart.o \
diff -Naur ns-allinone-2.35_orig/ns-2.35/Makefile.in ns-allinone-2.35/ns-2.35/Makefile.in
--- ns-allinone-2.35_orig/ns-2.35/Makefile.in	2020-07-24 19:47:50.753824774 +0300
+++ ns-allinone-2.35/ns-2.35/Makefile.in	2020-07-24 14:49:25.200638586 +0300
@@ -278,6 +278,7 @@
 	aomdv/aomdv_logs.o aomdv/aomdv.o \
 	aomdv/aomdv_rtable.o aomdv/aomdv_rqueue.o \
 	puma/puma.o \
+	phr/phr.o \
 	mdart/mdart_adp.o mdart/mdart_dht.o mdart/mdart_ndp.o \
 	mdart/mdart_neighbor.o mdart/mdart_queue.o mdart/mdart_table.o \
 	mdart/mdart.o \
diff -Naur ns-allinone-2.35_orig/ns-2.35/phr/phr.cc ns-allinone-2.35/ns-2.35/phr/phr.cc
--- ns-allinone-2.35_orig/ns-2.35/phr/phr.cc	1970-01-01 03:00:00.000000000 +0300
+++ ns-allinone-2.35/ns-2.35/phr/phr.cc	2020-07-24 13:57:06.791104187 +0300
@@ -0,0 +1,1038 @@
+/*//
+ * Copyright (c) 2017, Awos K. Ali, Loughborough University- UK
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+    *//////
+
+#include <phr/phr.h>
+#include <phr/phr_packet.h>
+#include <random.h>
+#include <cmu-trace.h>
+#include <energy-model.h>
+#include <math.h>
+#include<string.h>
+#include "mac.h"
+#include "ll.h"
+#include <address.h>
+#define max(a,b)        ( (a) > (b) ? (a) : (b) )
+#define CURRENT_TIME    Scheduler::instance().clock()
+
+#define DEBUG
+
+// ======================================================================
+//  TCL Hooking Classes
+/// ======================================================================
+
+int
+  hdr_phr::offset_;
+static
+  class
+  PHRHeaderClass:
+  public
+  PacketHeaderClass
+{
+public:
+  PHRHeaderClass ():
+  PacketHeaderClass ("PacketHeader/PHR", sizeof (hdr_all_phr))
+  {
+    bind_offset (&hdr_phr::offset_);
+  }
+}
+class_rtProtoPHR_hdr;
+
+static
+  class
+  PHRclass:
+  public
+  TclClass
+{
+public:
+  PHRclass ():
+  TclClass ("Agent/PHR")
+  {
+  }
+  TclObject *
+  create (int argc, const char *const *argv)
+  {
+    assert (argc == 5);
+    return (new PHR ((nsaddr_t) Address::instance ().str2addr (argv[4])));
+  }
+}
+
+class_rtProtoPHR;
+
+
+int
+PHR::command (int argc, const char *const *argv)
+{
+  if (argc == 2)
+    {
+      Tcl & tcl = Tcl::instance ();
+
+      if (strncasecmp (argv[1], "id", 2) == 0)
+	{
+	  tcl.resultf ("%d", index);
+	  return TCL_OK;
+	}
+
+      if (strncasecmp (argv[1], "start", 5) == 0)
+	{
+	  btimer.handle ((Event *) 0);
+	  rtimer.handle ((Event *) 0);
+
+	  return TCL_OK;
+	}
+
+
+      if (strncasecmp (argv[1], "stop-broadcast", 4) == 0)
+	{
+
+	  stop_ = 1;
+	  begin = 0;
+
+#ifdef DEBUG
+	  printf ("N (%.6f): node  %d, stop brodcasting  \n", CURRENT_TIME,
+		  index);
+#endif
+	  return TCL_OK;
+	}
+
+
+    }
+  else if (argc == 3)
+    {
+      if (strcmp (argv[1], "broadcast") == 0)
+	{
+
+	  iNode = (MobileNode *) (Node::get_node_by_address (atoi (argv[2])));
+	  nodeid = atoi (argv[2]);
+
+	  stop_ = 0;
+	  begin = 1;
+	  sendbroadcast (nodeid);
+	  return TCL_OK;
+	}
+
+
+      if (strcmp (argv[1], "index") == 0)
+	{
+	  index = atoi (argv[2]);
+	  return TCL_OK;
+	}
+
+
+      else if (strcmp (argv[1], "log-target") == 0
+	       || strcmp (argv[1], "tracetarget") == 0)
+	{
+	  logtarget = (Trace *) TclObject::lookup (argv[2]);
+	  if (logtarget == 0)
+	    return TCL_ERROR;
+	  return TCL_OK;
+	}
+
+      else if (strcmp (argv[1], "drop-target") == 0)
+	{
+
+
+	  return Agent::command (argc, argv);
+	  return TCL_OK;
+	}
+
+      else if (strcmp (argv[1], "if-queue") == 0)
+	{
+	  ifqueue = (PriQueue *) TclObject::lookup (argv[2]);
+
+	  if (ifqueue == 0)
+	    return TCL_ERROR;
+	  return TCL_OK;
+	}
+
+      else if (strcmp (argv[1], "port-dmux") == 0)
+	{
+	  dmux_ = (PortClassifier *) TclObject::lookup (argv[2]);
+	  if (dmux_ == 0)
+	    {
+	      fprintf (stderr, "%s: %s lookup of %s failed\n", __FILE__,
+		       argv[1], argv[2]);
+	      return TCL_ERROR;
+	    }
+	  return TCL_OK;
+	}
+    }
+
+  return Agent::command (argc, argv);
+}
+
+// ======================================================================
+//  Agent Constructor
+// ======================================================================
+
+PHR::PHR (nsaddr_t id):Agent (PT_PHR), btimer (this), sbtimer (this), rtimer (this),
+stoptimer (this)
+{
+
+#ifdef DEBUG
+
+#endif
+  index = id;
+  seqno = 1;
+  begin = 0;
+  //hops =0;
+  LIST_INIT (&bhead);
+  LIST_INIT (&rthead);
+  LIST_INIT (&cbrhead);
+  LIST_INIT (&knhead);
+  LIST_INIT (&parhead);
+  LIST_INIT (&sumhead);
+  stop_ = 0;
+  logtarget = 0;
+  ifqueue = 0;
+  r = 0;			//random float (0,1]
+  prob_prob = 0.5;
+  prob_forwarding = true;
+  broadcast = true;
+  pkt_count = 0;
+  max_par = 0;			// An inital value.
+  bind_time ("known_prob_", &known_prob);
+  bind_time ("unknown_prob_", &unknown_prob);
+  par_insert (0);		//add par inital value to the ParLIST
+  time_gab = 0;
+  rece_pkts = 0;
+}
+
+// ======================================================================
+//  Timer Functions
+// ======================================================================
+
+void
+Broadcasttimer::handle (Event *)
+{
+  agent->id_purge ();
+  agent->app_pkt_purge ();	//to expire cached cbr pkts. ids. every interval.
+  agent->known_purge ();	//to expire Known-List entries
+  agent->sum_purge ();		//to expire Sum-List entries
+  Scheduler::instance ().schedule (this, &intr, BCAST_ID_SAVE);
+}
+
+void
+SendBroadcastTimer::handle (Event *)
+{
+
+  // agent->sendbroadcast(dst);
+
+  double interval = MinBcInterval +
+    ((MaxBcInterval - MinBcInterval) * Random::uniform ());
+  assert (interval >= 0);
+  Scheduler::instance ().schedule (this, &intr, interval);
+  //   Scheduler::instance().schedule(this, &intr, BCAST_ID_SAVE);
+}
+
+void
+SendBroadcastTimer::stop (void)
+{
+  Scheduler & s = Scheduler::instance ();
+  s.cancel (&intr);
+  busy_ = 0;
+  //   Scheduler::instance().schedule(this, &intr, BCAST_ID_SAVE);
+}
+
+
+
+
+void
+Routecachetimer::handle (Event *)
+{
+  //agent->rt_purge ();
+#define FREQUENCY 0.5		// sec
+  Scheduler::instance ().schedule (this, &intr, FREQUENCY);
+}
+
+
+
+void
+PHR::sendbroadcast (nsaddr_t dest)
+{
+  Packet *p = Packet::alloc ();
+  struct hdr_cmn *ch = HDR_CMN (p);
+  struct hdr_ip *ih = HDR_IP (p);
+  struct hdr_phr_bc *bc = HDR_PHR_BC (p);
+
+  // Write Channel Header
+  ch->ptype () = PT_PHR;
+  ch->size () = IP_HDR_LEN + bc->size ();
+  ch->addr_type () = NS_AF_NONE;
+  ch->prev_hop_ = index;
+
+  // Write IP Header
+  ih->saddr () = index;
+  ih->daddr () = PHR_BROADCAST;
+  ih->sport () = RT_PORT;
+  ih->dport () = RT_PORT;
+  ih->ttl_ = NETWORK_DIAMETER;
+
+  // Write BC Header
+  bc->bc_type = PHR_BC;
+  bc->bc_bcast_id = seqno;
+  bc->bc_src = index;
+  bc->bc_dst = dest;
+  // Here we add the current hops no.from source.
+  bc->bc_hop_count = 1;
+  bc->bc_timestamp = CURRENT_TIME;
+
+  // increase sequence number for next bc
+  seqno += 1;
+  
+
+#ifdef DEBUG
+  printf ("S (%.6f): send broadcast by %d  \n", CURRENT_TIME, index);
+#endif
+  Scheduler::instance ().schedule (target_, p, 0.0);
+  //send(p,0);
+
+}
+
+void
+PHR::forward (Packet * p, nsaddr_t nexthop, double delay)
+{
+  struct hdr_cmn *ch = HDR_CMN (p);
+  struct hdr_ip *ih = HDR_IP (p);
+
+  if (ih->ttl_ == 0)
+    {
+      drop (p, DROP_RTR_TTL);
+    }
+  // if next hop != broadcast
+  if (nexthop != (nsaddr_t) IP_BROADCAST)
+    {
+      ch->next_hop_ = nexthop;
+      ch->prev_hop_ = index;
+      ch->addr_type () = NS_AF_INET;
+      ch->direction () = hdr_cmn::DOWN;
+    }
+  else
+    {
+      assert (ih->daddr () == (nsaddr_t) MAC_BROADCAST);
+      ch->prev_hop_ = index;
+      ch->addr_type () = NS_AF_NONE;
+      ch->direction () = hdr_cmn::DOWN;	// need to update the pkt.
+
+    }
+  Scheduler::instance ().schedule (target_, p, delay);
+}
+
+
+
+// ======================================================================
+//  Recv Packet
+// ======================================================================
+
+void
+PHR::recv (Packet * p, Handler *)
+{
+  struct hdr_cmn *ch = HDR_CMN (p);
+  struct hdr_ip *ih = HDR_IP (p);
+
+  // if the packet is routing protocol control packet, give the packet to agent
+  if (ch->ptype () == PT_PHR)
+    {
+      //    ih->ttl_ -= 1;
+      recv_phr (p);
+      return;
+    }
+
+  //  Must be a packet I'm originating
+  if ((ih->saddr () == index) && (ch->num_forwards () == 0))
+    {
+
+      // Add the IP Header. TCP adds the IP header too, so to avoid setting it twice,
+      // we check if  this packet is not a TCP or ACK segment.
+
+      if (ch->ptype () != PT_TCP && ch->ptype () != PT_ACK)
+	{
+	  ch->size () += IP_HDR_LEN;
+	}
+
+    }
+
+    //  Packet I'm forwarding...
+  else
+    {
+      if (--ih->ttl_ == 0)
+	{			// check if the time to live is exceeded
+	  drop (p, DROP_RTR_TTL);
+	  return;
+	}
+    }
+
+  // This is data packet, decide, forward the packet or not based on PHR.
+
+  recv_data (p);
+}
+
+
+// ======================================================================
+//  Recv Data Packet
+// ======================================================================
+
+void
+PHR::recv_data (Packet * p)
+{
+  struct hdr_ip *ih = HDR_IP (p);
+  struct hdr_cmn *ch = HDR_CMN (p);
+  struct hdr_phr *ph = HDR_PHR (p);
+  //////Calculate the probability of forwarding.
+  ParList *pr = par_lookup ();
+  bool reset;
+
+  rece_pkts += 1;		// increase no. of received pkts.
+  S = sum ();
+  if (pr->par_expire <= CURRENT_TIME)
+    {
+      reset = true;
+      pr->par_expire = CURRENT_TIME + PAR_RESET;	//vaild for 2 sec.
+    }
+  else
+    {
+      reset = false;
+    }
+  //get the PAR(Packet Arriving Rate)
+  par = Record (reset);
+  length = length_of_list ();
+  //SAVE PAR VALUE INTO A LIST EVERY SECOND OR SO.
+  time_slot = CURRENT_TIME - time_gab;
+  if (time_slot > (1.1))
+    {
+      // printf("Insert rece_pkts %d  into the sum list at %.3f \n",rece_pkts, CURRENT_TIME);
+      time_gab = CURRENT_TIME;
+      sum_insert (rece_pkts);	//par);
+      //par_update(rece_pkts);
+      rece_pkts = 0;		//reset the counter
+      //par =0;
+    }
+
+
+  //S is sumation of 5 par s.
+  //update the max_par value.
+
+  if (S > 0)
+    {
+      PAR = S / length;		//if we need to do average.
+
+      if (max_par < PAR)
+	{
+	  max_par = PAR * 2;
+	 	}
+      prob_prob = 1.0 - (PAR / max_par);
+
+    }
+  //To Avoid full brodcast at the begning.
+  else
+    {
+      prob_prob = 0.6;
+    }
+
+
+  ////////END OF FORWARDING PROBABILITY CALCULATION\\\\\\\\\
+
+
+//Check if the pkt received before.
+  if (app_pkt_lookup (ih->saddr (), ch->uid ()))
+    {				//if pkt come from different neighbour save the neighbour and discard pkt.
+      KnownList *kn1 = known_lookup (ph->ph);
+      if (kn1 == NULL)
+	{
+	  known_insert (ph->ph, 1);
+	}
+      else
+	{
+	  //just update the neighbout info.
+	  kn1->hops_to_dest = 1;
+	  kn1->phr_expire = CURRENT_TIME + DEFAULT_ENTRY_EXPIRE;
+	}
+
+      Packet::free (p);
+  //    drop(p, DROP_RTR_ROUTE_LOOP);
+      return;
+    }
+#ifdef DEBUG
+  // printf ("packet_id %d now on node %d and its hop_count is %d PH is %d \n",
+  //      ch->uid (), index, ph->hops_so_far, ph->ph);
+#endif
+  //Cache cbr bcast pkt.
+  app_pkt_insert (ih->saddr (), ch->uid ());
+
+  //previous hop
+  nsaddr_t neighbour = ph->ph;
+  ph->ph = index;
+  /////////////
+#ifdef DEBUG
+  //printf ("Receive at %d, id %d \n", index, ch->uid ());
+#endif
+  //Generate random float value (0,1]
+  r = ((float) rand ()) / (float) (RAND_MAX);
+  if (ih->ttl () == 32)		//If I am the source node
+    {
+      //fill phr pkt header at source node
+      ch->prev_hop_ = index;
+      ch->addr_type () = NS_AF_NONE;
+      ch->direction () = hdr_cmn::DOWN;
+      ch->next_hop_ = MAC_BROADCAST;
+      ph->dest_ = ih->daddr ();
+      ih->daddr () = MAC_BROADCAST;
+      ph->src = ih->saddr ();
+      ph->pkt_id = ch->uid ();
+      ph->hops_so_far = 1;
+      //To reduce no. of forwarding.
+      // look up for the destination
+      KnownList *kn = known_lookup (ph->dest_);
+      if (kn != NULL)
+	{
+	  ph->dist_to_dest = kn->hops_to_dest;
+	  ph->known_flag = true;
+	  /* printf ("I am the source and I know where the dest. is, pkt_id is \n",*/
+	
+	}
+      else
+	{
+	  //  printf ("dest. is unkown %d \n", index);
+	  ph->dist_to_dest = NETWORK_DIAMETER;
+	  ph->known_flag = false;
+
+	}
+      forward (p, MAC_BROADCAST, 0.0);
+      //  printf ("source node send packet %d on node %d \n", ch->uid (), index);
+    }
+  // if I am the destination, send the pkt to the upper layers.
+  else if (index == ph->dest_)
+    {
+      // look up for the src.
+      KnownList *kn = known_lookup (ph->src);
+      if (kn == NULL)
+	{
+	  //  printf ("Insert to known list on dest. node %d \n", index);
+	  known_insert (neighbour, 1);	//Adding neighbour to the known-list
+	  known_insert (ph->src, ph->hops_so_far);
+	}
+      else
+	{
+	  // update the Known list
+	  //printf ("Update known list on dest. node %d \n", index);
+	  kn->hops_to_dest = ph->hops_so_far;
+	  kn->phr_expire = CURRENT_TIME + DEFAULT_ENTRY_EXPIRE;
+	}
+      //printf ("sending up stack %d, %d\n", index, ih->daddr ());
+      ch->addr_type () = NS_AF_INET;
+      ih->daddr () = (nsaddr_t) ph->dest_;
+      dmux_->recv (p, 0);
+      
+    }
+
+  else
+    {
+      KnownList *kn = known_lookup (ph->dest_);
+      if (kn == NULL)
+	{
+	  KnownList *nbr = known_lookup (neighbour);
+	  if (nbr == NULL)
+	    {
+	      known_insert (neighbour, 1);	//Adding neighbour to the known-list
+	    }
+	  else
+	    {
+	      nbr->phr_expire = CURRENT_TIME + DEFAULT_ENTRY_EXPIRE;
+	    }
+	  KnownList *knsrc = known_lookup (ph->src);
+	  if (knsrc == NULL)
+	    {
+	      known_insert (ph->src, ph->hops_so_far);
+	    }
+	  else
+	    {
+	      knsrc->hops_to_dest = ph->hops_so_far;
+	      knsrc->phr_expire = CURRENT_TIME + DEFAULT_ENTRY_EXPIRE;
+	    }
+	  broadcast = prob_forwarding;	//
+	  broadcast = broadcast && (r <= prob_prob);	//<= unknown_prob);//changed to &&
+	  broadcast = broadcast && (ph->known_flag == false);
+	  if (broadcast)
+	    {
+	      ph->hops_so_far += 1;
+	      ph->dist_to_dest -= 1;
+	      forward (p, MAC_BROADCAST, DELAY);
+	    }
+	  else
+	    {
+	      //Drop if the flag is set and prob value is low.
+	      drop(p, DROP_PHR_DKNOW);
+	      return;
+	    }
+
+	}
+      else
+	{
+	  if (kn->hops_to_dest <= ph->dist_to_dest)
+	    {
+	      // prepare the packet for forwarding/
+	      ph->hops_so_far += 1;
+	      ph->known_flag = true;
+	      ph->dist_to_dest = kn->hops_to_dest;
+	      //Check if I received from this src before.
+	      KnownList *kn2 = known_lookup (ph->src);
+	      if (kn2 == NULL)
+		{
+		  known_insert (neighbour, 1);	//Adding neighbour to the known-list
+		  known_insert (ph->src, ph->hops_so_far);
+		}
+	      else
+		{		//update the entry./
+		  // kn2->hops_to_dest = ph->hops_so_far;
+		  kn2->phr_expire = CURRENT_TIME + DEFAULT_ENTRY_EXPIRE;
+		}
+
+	      //  send the pkt. probabilistically.
+	      ////***************
+	      if (prob_forwarding && r < prob_prob)
+		{		// known_prob){
+		  forward (p, MAC_BROADCAST, DELAY);
+		}
+	      else
+		{
+		 Packet::free (p);
+		 return;
+
+		}
+	    }
+	  else
+	    {
+
+	       drop(p, DROP_PHR_PH_CLOSER);
+
+	    }
+	}
+    }
+}
+
+// ======================================================================
+//  Recv PHR Packet
+// ======================================================================
+void
+PHR::recv_phr (Packet * p)
+{
+  struct hdr_phr *wh = HDR_PHR (p);
+
+  assert (HDR_IP (p)->sport () == RT_PORT);
+  assert (HDR_IP (p)->dport () == RT_PORT);
+
+  // What kind of packet is this
+  switch (wh->pkt_type)
+    {
+
+    case PHR_BC:
+      recevbroadcast (p);
+      break;
+
+      //case WFRP_ERROR:
+      //recv_error(p);
+      //break;
+      // We can add new function here to process Unicast Packet routing(WFRP_UNI)
+    default:
+      fprintf (stderr, "Invalid packet type (%x)\n", wh->pkt_type);
+      exit (1);
+    }
+}
+
+
+// ======================================================================
+//  Recv Broadcast Packet
+// ======================================================================
+void
+PHR::recevbroadcast (Packet * p)
+{
+  struct hdr_ip *ih = HDR_IP (p);
+  struct hdr_phr_bc *bc = HDR_PHR_BC (p);
+
+  Routecache *rt = rt_lookup (bc->bc_src);
+
+  if (!rt)
+    {
+      rt_insert (bc->bc_src, bc->bc_bcast_id, ih->saddr (), bc->bc_hop_count);
+    }
+  // I have originated the packet, just drop it
+  if (bc->bc_src == index)
+    {
+      //drop(p, DROP_RTR_ROUTE_LOOP);
+      Packet::free (p);
+      return;
+    }
+  // If I received this bcast pkt befor.
+  if (id_lookup (bc->bc_src, bc->bc_bcast_id))
+    {
+
+#ifdef DEBUG
+      fprintf (stderr, "%s: discarding brodcast\n", __FUNCTION__);
+#endif // DEBUG
+      Packet::free (p);
+
+      return;
+    }
+  //Cache bcast pkt.
+  id_insert (bc->bc_src, bc->bc_bcast_id);
+ #ifdef DEBUG
+  printf ("R (%.6f): recv broadcast by %d, src:%d, seqno:%d, hop: %d \n",
+	  CURRENT_TIME, index, bc->bc_src, bc->bc_bcast_id, bc->bc_hop_count);
+#endif
+  // if I am the destination then receive the pkt and don't froward it.
+  if (bc->bc_dst == index)
+    {
+
+#ifdef DEBUG
+      fprintf (stderr, "%d : pkt received by its destination \n", index);
+#endif
+      // dmux_->recv(p, 0);
+      // Packet::free(p);
+    }
+  else
+    {
+      double delay = 0.1 + Random::uniform ();
+      forward (p, PHR_BROADCAST, delay);
+    }
+
+
+}
+
+//=====================================================================
+///////The following functions handle the sum list (PAR to be added and calculate
+// the mean of PAR to be used in calcualtion of probability of forwarding)
+//=====================================================================
+void
+PHR::sum_insert (double PAR)
+{
+  SumList *sm = new SumList (PAR);
+
+  sm->sum_expire = CURRENT_TIME + 1.11;	//1.11
+  //sm->summ = PAR;
+  LIST_INSERT_HEAD (&sumhead, sm, sum_link);
+  //printf ("X:%.3f, Y:%.3f \n",rt->rt_xpos, rt->rt_ypos);
+}
+
+void
+PHR::sum_purge ()
+{
+  SumList *b = sumhead.lh_first;
+  SumList *bn;
+  double now = CURRENT_TIME;
+
+  for (; b; b = bn)
+    {
+      bn = b->sum_link.le_next;
+      if (b->sum_expire <= now)
+	{
+	  LIST_REMOVE (b, sum_link);
+	  delete b;
+	}
+    }
+}
+
+float
+PHR::sum ()
+{
+  // float min =0.0;
+  float S = 0.0;
+  SumList *s = sumhead.lh_first;
+  // min = s->summ;
+  for (; s != NULL; s = s->sum_link.le_next)
+    {
+      S += s->summ;
+
+    }
+
+  return S;
+}
+
+//=====================================================================
+///////Reset the pkt received counter
+//=====================================================================
+void
+PHR::par_insert (double counter)
+{
+  ParList *pr = new ParList (counter);
+
+  pr->count = counter;
+  pr->par_expire = CURRENT_TIME + PAR_RESET;
+  LIST_INSERT_HEAD (&parhead, pr, par_link);
+  //printf ("X:%.3f, Y:%.3f \n",rt->rt_xpos, rt->rt_ypos);
+}
+
+void
+PHR::par_update (double rece_pkts)
+{
+  ParList *p = parhead.lh_first;
+  p->count = rece_pkts;
+  p->par_expire = CURRENT_TIME + PAR_RESET;
+
+}
+
+ParList *
+PHR::par_lookup ()
+{
+  ParList *p = parhead.lh_first;
+
+  /*for (; p; p = p->par_link.le_next)
+   {
+   if (p->count != 0){
+  return p;			
+  }
+  else { return 0;}*/
+
+    return p;
+}
+
+bool PHR::Reset ()
+{
+  ParList *
+    par = parhead.lh_first;
+
+
+  if (par->par_expire <= CURRENT_TIME)
+    {
+      return true;
+    }
+  else
+    {
+      return false;
+       }
+}
+
+///This function record no. of received pkts.
+double
+PHR::Record (bool reset)
+{
+  if (!reset)
+    {
+      pkt_count += 1;
+    }
+  else
+    {
+      pkt_count = 0;
+
+    }
+  return pkt_count;
+}
+
+int
+PHR::length_of_list ()
+{
+  SumList *p = sumhead.lh_first;
+  int count = 0;
+  for (; p != NULL; p = p->sum_link.le_next)
+    {
+      ++count;
+    }
+  return count;
+}
+// ======================================================================
+//  Manage Known list
+// ======================================================================
+void
+PHR::known_insert (nsaddr_t src, u_int8_t hopcount)
+{
+  KnownList *kn = new KnownList (src, hopcount);
+
+  kn->hops_to_dest = hopcount;
+  kn->phr_expire = CURRENT_TIME + DEFAULT_ENTRY_EXPIRE;
+  LIST_INSERT_HEAD (&knhead, kn, kn_link);
+}
+
+
+
+void
+PHR::known_purge ()
+{
+  KnownList *b = knhead.lh_first;
+  KnownList *bn;
+  double now = CURRENT_TIME;
+
+  for (; b; b = bn)
+    {
+      bn = b->kn_link.le_next;
+      if (b->phr_expire <= now)
+	{
+	  LIST_REMOVE (b, kn_link);
+	  delete b;
+	}
+    }
+}
+
+KnownList *
+PHR::known_lookup (nsaddr_t dst)
+{
+  KnownList *r = knhead.lh_first;
+
+  for (; r; r = r->kn_link.le_next)
+    {
+      if (r->phr_dst == dst)
+	return r;
+    }
+
+  return NULL;
+}
+
+KnownList *
+PHR::get_neighbours (nsaddr_t ph)
+{
+
+  KnownList *r = knhead.lh_first;
+
+  for (; r; r = r->kn_link.le_next)
+    {
+      if (r->hops_to_dest == 1)
+	return r;
+    }
+
+  return NULL;
+
+}
+
+//======================================================================
+void
+PHR::app_pkt_insert (nsaddr_t id, u_int32_t bid)
+{
+  Broadcastcbr *b = new Broadcastcbr (id, bid);
+  double now = CURRENT_TIME;
+  assert (b);
+  b->expire = now + BCAST_ID_SAVE;
+  b->src = id;
+  b->id = bid;
+  LIST_INSERT_HEAD (&cbrhead, b, link);
+}
+
+bool PHR::app_pkt_lookup (nsaddr_t id, u_int32_t bid)
+{
+  Broadcastcbr *
+    b = cbrhead.lh_first;
+
+  // Search the list for a match of source and cbr_id
+  for (; b; b = b->link.le_next)
+    {
+      if ((b->src == id) && (b->id == bid))
+	return true;
+    }
+  return false;
+}
+
+void
+PHR::app_pkt_purge ()
+{
+  Broadcastcbr *b = cbrhead.lh_first;
+  Broadcastcbr *bn;
+  double now = CURRENT_TIME;
+//expire entries every interval
+  for (; b; b = bn)
+    {
+      bn = b->link.le_next;
+      if (b->expire <= now)
+	{
+	  LIST_REMOVE (b, link);
+	  delete b;
+	}
+    }
+}
+
+
+bool PHR::id_lookup (nsaddr_t id, u_int32_t bid)
+{
+  BroadcastID *
+    b = bhead.lh_first;
+
+  // Search the list for a match of source and bid
+  for (; b; b = b->link.le_next)
+    {
+      // if  (b->id == bid)
+      if ((b->src == id) && (b->id == bid))
+	return true;
+    }
+  return false;
+}
+
+
+
+void
+PHR::id_insert (nsaddr_t id, u_int32_t bid)
+{
+  BroadcastID *b = new BroadcastID (id, bid);
+
+  assert (b);
+  b->expire = CURRENT_TIME + BCAST_ID_SAVE;
+  b->src = id;
+  b->id = bid;
+  LIST_INSERT_HEAD (&bhead, b, link);
+}
+
+
+
+void
+PHR::id_purge ()
+{
+  BroadcastID *b = bhead.lh_first;
+  BroadcastID *bn;
+  double now = CURRENT_TIME;
+
+  for (; b; b = bn)
+    {
+      bn = b->link.le_next;
+      if (b->expire <= now)
+	{
+	  LIST_REMOVE (b, link);
+	  delete b;
+	}
+    }
+}
+
+void
+PHR::rt_insert (nsaddr_t src, u_int32_t id, nsaddr_t nexthop,
+		u_int8_t hopcount)
+{
+  Routecache *rt = new Routecache (src, id);
+
+  rt->rt_nexthop = nexthop;
+  rt->rt_state = ROUTE_FRESH;
+  rt->rt_hopcount = hopcount;
+  rt->rt_expire = CURRENT_TIME + DEFAULT_ENTRY_EXPIRE;
+  //rt->rt_last_node_hops_to_dst = last_node_hops_to_dst;
+  LIST_INSERT_HEAD (&rthead, rt, rt_link);
+  //printf ("X:%.3f, Y:%.3f \n",rt->rt_xpos, rt->rt_ypos);
+}
+
+Routecache *
+PHR::rt_lookup (nsaddr_t dst)
+{
+  Routecache *r = rthead.lh_first;
+
+  for (; r; r = r->rt_link.le_next)
+    {
+      if (r->rt_dst == dst)
+	return r;
+    }
+
+  return NULL;
+}
diff -Naur ns-allinone-2.35_orig/ns-2.35/phr/phr.h ns-allinone-2.35/ns-2.35/phr/phr.h
--- ns-allinone-2.35_orig/ns-2.35/phr/phr.h	1970-01-01 03:00:00.000000000 +0300
+++ ns-allinone-2.35/ns-2.35/phr/phr.h	2020-07-24 13:57:06.791104187 +0300
@@ -0,0 +1,352 @@
+/*
+ * Copyright (c) 2010, Elmurod A. Talipov, Yonsei University
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __phr_h__
+#define __phr_h__
+
+#include <cmu-trace.h>
+#include <priqueue.h>
+//#include <phr/phr_rqueue.h>
+#include <classifier/classifier-port.h>
+#include "mac/mac.h"
+#include "mac/ll.h"
+#include <mobilenode.h>
+#include "timer-handler.h"
+#define NETWORK_DIAMETER		64
+#define ALLOWED_BC_LOSS                 3	//packets
+//#define DEFAULT_BEACON_INTERVAL               10 // seconds;
+#define DEFAULT_ENTRY_EXPIRE 		2	// seconds;
+#define PHR_BROADCAST	((u_int32_t) 0xffffffff)	// Broadcast address
+//#define ROUTE_PURGE_FREQUENCY         2 // seconds
+
+
+
+#define ROUTE_FRESH		0x01
+#define ROUTE_EXPIRED		0x02
+#define ROUTE_FAILED		0x03
+
+class PHR;
+#define BCAST_ID_SAVE           5	// 5 seconds
+#define BC_INTERVAL          1	// 1000 ms
+#define MaxBcInterval        (1.25 * BC_INTERVAL)
+#define MinBcInterval        (0.75 * BC_INTERVAL)
+#define DELAY                (Random::uniform()*0.05)
+#define PAR_RESET            1.0
+// ======================================================================
+//  Timers : Beacon Timer, Route Cache Timer
+// ======================================================================
+
+class Broadcasttimer:public Handler
+{
+public:
+  Broadcasttimer (PHR * a):agent (a)
+  {
+  }
+  void handle (Event *);
+private:
+  PHR * agent;
+  Event intr;
+};
+
+
+class SendBroadcastTimer:public Handler
+{
+public:
+  SendBroadcastTimer (PHR * a):agent (a)
+  {
+    busy_ = 0;
+  }
+  void handle (Event *);
+  void stop (void);
+  inline int busy (void)
+  {
+    return busy_;
+  }
+
+  nsaddr_t dst;
+private:
+  PHR * agent;
+  Event intr;
+  int busy_;
+
+
+};
+
+
+class Routecachetimer:public Handler
+{
+public:
+Routecachetimer (PHR * a):agent (a)
+  {
+  }
+  void handle (Event *);
+private:
+  PHR * agent;
+  Event intr;
+};
+
+
+class Routecache
+{
+  friend class PHR;
+public:
+    Routecache (nsaddr_t bsrc, u_int32_t bid)
+  {
+    rt_dst = bsrc;
+    rt_seqno = bid;
+  }
+protected:
+    LIST_ENTRY (Routecache) rt_link;	//rt_link ia the object of the struct that genrtated by LIST_ENTRY.
+  u_int32_t rt_seqno;		// route sequence number
+  nsaddr_t rt_dst;		// route destination
+  nsaddr_t rt_nexthop;		// next hop node towards the destionation
+  nsaddr_t rt_ph;		// previous hop
+
+  u_int8_t rt_state;		// state of the route: FRESH, EXPIRED, FAILED (BROKEN)
+  u_int8_t rt_hopcount;		// number of hops up to the destination (sink)
+  u_int8_t rt_last_node_hops_to_dst;	// last node hops to destination.
+  double rt_expire;		// when route expires : Now + DEFAULT_ROUTE_EXPIRE
+
+};
+
+LIST_HEAD (phr_rtcache, Routecache);
+
+//=======================================================================
+// KNOWN LIST
+//=======================================================================
+class KnownList
+{
+  friend class PHR;
+public:
+    KnownList (nsaddr_t bsrc, u_int8_t hops)
+  {
+    phr_dst = bsrc;
+    hops_to_dest = hops;
+  }
+protected:
+    LIST_ENTRY (KnownList) kn_link;
+  nsaddr_t phr_dst;		//destination
+  u_int8_t hops_to_dest;	// no. of hops to destination
+  double phr_expire;
+  //nsaddr_t           nodeid;
+};
+
+LIST_HEAD (phr_known, KnownList);
+///////////////////////////////////////////////////////////
+// PAR LIST TO COUNT PKTS. RATE /PAR_RESET VALUE(TIME)
+////////////////////////////////////////////////////////////
+class ParList
+{
+  friend class PHR;
+public:
+    ParList (double counter)
+  {
+    count = counter;
+  }
+protected:
+    LIST_ENTRY (ParList) par_link;
+  double count;			//received pkt no.
+  double par_expire;		//reset counter
+
+};
+
+LIST_HEAD (par_count, ParList);
+
+///////////////////////////////////////////////////////////
+// SUM LIST TO COUNT PKTS. RATE /PAR_RESET VALUE(TIME)
+////////////////////////////////////////////////////////////
+class SumList
+{
+  friend class PHR;
+public:
+    SumList (double sum)
+  {
+    summ = sum;
+  }
+protected:
+    LIST_ENTRY (SumList) sum_link;
+  double summ;			//PAR/PAR_REST.
+  double sum_expire;		//expire sum value evey 5 seconds
+  double sumation;
+};
+
+LIST_HEAD (sumcount, SumList);
+///////////////////////////////////
+
+class BroadcastID
+{
+  friend class PHR;
+public:
+    BroadcastID (nsaddr_t i, u_int32_t b)
+  {
+    src = i;
+    id = b;
+  }
+protected:
+    LIST_ENTRY (BroadcastID) link;
+  nsaddr_t src;
+  u_int32_t id;
+  double expire;		// now + BCAST_ID_SAVE s
+};
+
+LIST_HEAD (phr_bcache, BroadcastID);
+
+/*
+Recives cbr packet cash
+ */
+class Broadcastcbr
+{
+  friend class PHR;
+public:
+    Broadcastcbr (nsaddr_t i, u_int32_t b)
+  {
+    src = i;
+    id = b;
+  }
+protected:
+    LIST_ENTRY (Broadcastcbr) link;
+  nsaddr_t src;
+  u_int32_t id;
+  double expire;		// now + BCAST_ID_SAVE s
+};
+
+LIST_HEAD (cbr_bcache, Broadcastcbr);
+// ======================================================================
+//  PHR Routing Agent : the routing protocol
+// ======================================================================
+class PHR:public Agent
+{
+  friend class BroadcastTimer;
+  friend class SendBroadcastTimer;
+  friend class Routecachetimer;
+  friend class stopbroadcasttimer;
+
+public:
+    PHR (nsaddr_t id);
+
+  void recv_data (Packet * p);
+  void recv (Packet * p, Handler *);
+  // void             startbroad();
+  int command (int, const char *const *);
+  // broadcast management in each node.
+  void id_insert (nsaddr_t id, u_int32_t bid);
+  bool id_lookup (nsaddr_t id, u_int32_t bid);
+  void app_pkt_insert (nsaddr_t id, u_int32_t bid);
+  bool app_pkt_lookup (nsaddr_t id, u_int32_t bid);
+  void app_pkt_purge ();
+  void rt_insert (nsaddr_t src, u_int32_t id, nsaddr_t nexthop,
+		  u_int8_t hopcount);
+  Routecache *rt_lookup (nsaddr_t dst);
+  void id_purge (void);
+  void par_insert (double counter);
+  void sum_insert (double p);
+  void sum_purge (void);
+  float sum ();
+  bool Reset ();
+  double Record (bool reset);
+  ParList *par_lookup ();
+  int length_of_list ();
+  double S;
+  // Packet broadcast Routines.
+  void sendbroadcast (nsaddr_t dest);
+  void stopbroadcast (Packet * p);
+  void forward (Packet * p, nsaddr_t nexthop, double delay);
+  void recevbroadcast (Packet * p);
+  void recv_phr (Packet * p);
+  void par_update (double rece_pkts);
+  Routecache *rt_add (nsaddr_t id);
+  KnownList *known_lookup (nsaddr_t dst);
+  KnownList *get_neighbours (nsaddr_t ph);
+  void known_insert (nsaddr_t dst, u_int8_t hopcount);
+  void known_purge ();
+  nsaddr_t *thisphr;
+  float time_slot;
+
+  nsaddr_t index;		// IP Address of this node
+  nsaddr_t source;
+  nsaddr_t dest;
+  u_int32_t seqno;		// Sequence Number
+  int bid;			// Broadcast ID
+  phr_bcache bhead;		// broadcast head
+  cbr_bcache cbrhead;		//cbr broadcast id
+  phr_known knhead;		// known list head
+  phr_rtcache rthead;		// route head
+  par_count parhead;		//PAR head
+  sumcount sumhead;		//SUM head
+  Broadcasttimer btimer;	// broadcast timer
+  SendBroadcastTimer sbtimer;	// send broadcast timer
+  SendBroadcastTimer stoptimer;	// stop brodcast timer
+  Routecachetimer rtimer;	// route cache timer
+  int nodeid;			// dsetination node id for bc pkts.
+  int rece_pkts;		// counter for Received pkts.
+
+  //  A mechanism for logging the contents of the routing table.
+  Trace *logtarget;
+
+  // A pointer to the network interface queue that sits between the "classifier" and the "link layer"
+  PriQueue *ifqueue;
+  //****** probability of forwarding vars.*****//
+  float r;			// generating random float (0,1]
+  double prob_prob;
+  bool prob_forwarding;
+  bool broadcast;		//if broadcast {send pkts out}
+  // Port classifier for passing packets up to agents
+  PortClassifier *dmux_;
+  MobileNode *iNode;
+  int stop_;			//to stop sending out pkts
+  int begin;			//to avoid send broadcast bc pkts when simulation starts till to told to.
+  double known_prob;
+  double unknown_prob;
+  int length;			//length of par list
+  double PAR;			//mean of par
+  float kn_pro;
+  float unkn_pro;
+  double par;			//Packet Arraivl Rate
+  double max_par;		//Max Packet Arraivl Rate
+  double pkt_count;		//counter for no. of received pkts.
+  float time_gab;
+
+protected:
+  void rt_purge (void);
+  //void enque (Routecache * rt, Packet * p);
+  //Packet *deque (Routecache * rt);
+  int initialized ()
+  {
+    return 1 && target_;
+  }
+  //phr_rqueue rqueue;
+
+
+
+};
+
+
+
+
+
+
+
+#endif /* __phr_h__ */
diff -Naur ns-allinone-2.35_orig/ns-2.35/phr/phr_packet.h ns-allinone-2.35/ns-2.35/phr/phr_packet.h
--- ns-allinone-2.35_orig/ns-2.35/phr/phr_packet.h	1970-01-01 03:00:00.000000000 +0300
+++ ns-allinone-2.35/ns-2.35/phr/phr_packet.h	2020-07-24 13:57:06.791104187 +0300
@@ -0,0 +1,110 @@
+/* 
+ * Copyright (c) 2010, Elmurod A. Talipov, Yonsei University
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __phr_packet_h__
+#define __phr_packet_h__
+//#include <packet.h>
+
+// ======================================================================
+//  Packet Formats: Beacon, Data, Error
+// ======================================================================
+ 
+#define PHR_BC      0x01
+
+
+// ======================================================================
+// Direct access to packet headers
+// ======================================================================
+
+#define  HDR_PHR(p)             ((struct hdr_phr*)hdr_phr::access(p))
+#define HDR_PHR_BC(p)   	((struct hdr_phr_bc*)hdr_phr::access(p))
+
+// ======================================================================
+// Default PHR packet
+// ======================================================================
+
+struct hdr_phr {
+	u_int8_t	pkt_type;
+        nsaddr_t        dest_;
+        u_int8_t        pkt_id;
+        nsaddr_t        src;
+        bool            known_flag;
+        nsaddr_t        ph; //previous hop id.
+        u_int8_t        hops_so_far;
+        u_int8_t        dist_to_dest;
+        
+	// header access
+	static int offset_;
+	inline static int& offset() { return offset_;}
+	inline static hdr_phr* access(const Packet *p) {
+	       return (hdr_phr*) p->access(offset_);
+	}
+	inline int size() {
+		int sz = 0;
+		sz = sizeof(struct hdr_phr);
+		assert(sz>=0);
+		return sz;
+	}
+	
+
+};
+struct hdr_phr_bc {
+        u_int8_t        bc_type;	// Packet Type
+       
+        u_int8_t        bc_hop_count;   // Hop Count
+        u_int32_t       bc_bcast_id;    // Broadcast ID
+        nsaddr_t        bc_dst;         // Destination IP Address
+        nsaddr_t        bc_src;         // Source IP Address
+        u_int32_t       bc_src_seqno;   // Source Sequence Number
+        double          bc_timestamp;   // when REQUEST sent;
+					// used to compute route discovery latency
+       
+  
+
+  inline int size() { 
+  int sz = 0;
+ 
+  	sz = sizeof(struct hdr_phr_bc);
+  	assert (sz >= 0);
+	return sz;
+  }
+};
+
+
+
+
+
+
+
+// For size calculation of header-space reservation
+union hdr_all_phr {
+	hdr_phr		        phr;
+        hdr_phr_bc              bc;
+  
+};
+
+#endif /* __phr_packet_h__ */
+
diff -Naur ns-allinone-2.35_orig/ns-2.35/queue/priqueue.cc ns-allinone-2.35/ns-2.35/queue/priqueue.cc
--- ns-allinone-2.35_orig/ns-2.35/queue/priqueue.cc	2020-07-24 19:47:50.761824949 +0300
+++ ns-allinone-2.35/ns-2.35/queue/priqueue.cc	2020-07-24 14:56:10.570841528 +0300
@@ -91,6 +91,7 @@
                 case PT_TORA:
                 case PT_AODV:
 		case PT_AOMDV:
+		case PT_PHR:		
 		case PT_MDART:
 			recvHighPriority(p, h);
                         break;
diff -Naur ns-allinone-2.35_orig/ns-2.35/tcl/lib/ns-agent.tcl ns-allinone-2.35/ns-2.35/tcl/lib/ns-agent.tcl
--- ns-allinone-2.35_orig/ns-2.35/tcl/lib/ns-agent.tcl	2020-07-24 19:47:50.897827918 +0300
+++ ns-allinone-2.35/ns-2.35/tcl/lib/ns-agent.tcl	2020-07-24 14:39:27.365193789 +0300
@@ -197,3 +197,10 @@
 Agent/AOMDV set dport_   0
 Agent/AOMDV set aomdv_prim_alt_path_len_diff_ 1
 Agent/AOMDV set aomdv_max_paths_ 3
+
+Agent/PHR instproc init args {
+         $self next $args
+}
+Agent/PHR set sport_   0
+Agent/PHR set dport_   0
+
diff -Naur ns-allinone-2.35_orig/ns-2.35/tcl/lib/ns-autoconf.tcl ns-allinone-2.35/ns-2.35/tcl/lib/ns-autoconf.tcl
--- ns-allinone-2.35_orig/ns-2.35/tcl/lib/ns-autoconf.tcl	2020-07-24 19:47:50.897827918 +0300
+++ ns-allinone-2.35/ns-2.35/tcl/lib/ns-autoconf.tcl	2020-07-24 18:50:21.874910485 +0300
@@ -40,9 +40,9 @@
 	The wrong version of perl may break the test suites.\
 	Reconfigure and rebuild ns if this is a problem.\
 "
-checkout_executable TCLSH "/home/coaka/Documents/ns-original/ns-allinone-2.35/bin/tclsh8.5" tclsh "\
+checkout_executable TCLSH "/home/coaka/Downloads/ns-allinone-2.35/bin/tclsh8.5" tclsh "\
 	When configured, ns found the right version of tclsh in\
-	/home/coaka/Documents/ns-original/ns-allinone-2.35/bin/tclsh8.5
+	/home/coaka/Downloads/ns-allinone-2.35/bin/tclsh8.5
 	but it doesn't seem to be there anymore, so\
 	ns will fall back on running the first tclsh in your path.\
 	The wrong version of tclsh may break the test suites.\
diff -Naur ns-allinone-2.35_orig/ns-2.35/tcl/lib/ns-lib.tcl ns-allinone-2.35/ns-2.35/tcl/lib/ns-lib.tcl
--- ns-allinone-2.35_orig/ns-2.35/tcl/lib/ns-lib.tcl	2020-07-24 19:47:50.897827918 +0300
+++ ns-allinone-2.35/ns-2.35/tcl/lib/ns-lib.tcl	2020-07-24 14:36:35.512457324 +0300
@@ -636,6 +636,10 @@
 		    MDART {
 			    set ragent [$self create-mdart-agent $node]
 		    }
+		   PHR {
+			    set ragent [$self create-phr-agent $node]
+		    }	
+			
                     PUMA {
                             set ragent [$self create-puma-agent $node]
                     }
@@ -882,6 +886,15 @@
         $node set ragent_ $ragent
         return $ragent
 }
+#PHR By Awos Kh. Ali & Iain Phillips
+Simulator instproc create-phr-agent { node } {
+           #  Create PHR routing agent
+           set ragent [new Agent/PHR [$node node-addr]]
+           $self at 0.0 "$ragent start"
+           $node set ragent_ $ragent
+           return $ragent
+}
+##
 
 Simulator instproc use-newtrace {} {
 	Simulator set WirelessNewTrace_ 1
diff -Naur ns-allinone-2.35_orig/ns-2.35/tcl/lib/ns-mobilenode.tcl ns-allinone-2.35/ns-2.35/tcl/lib/ns-mobilenode.tcl
--- ns-allinone-2.35_orig/ns-2.35/tcl/lib/ns-mobilenode.tcl	2020-07-24 19:47:50.897827918 +0300
+++ ns-allinone-2.35/ns-2.35/tcl/lib/ns-mobilenode.tcl	2020-07-24 14:47:52.834519338 +0300
@@ -197,7 +197,13 @@
 	if {$aodvonly != -1 } {
 		$agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
 	}
-	
+
+	# Special processing for PHR
+        set phronly [string first "PHR" [$agent info class]]
+        if {$phronly != -1 } {
+          $agent if-queue [$self set ifq_(0)]   ;# ifq between LL and MAC
+        }
+
 	#<zheng: add>
 	# Special processing for ZBR
 	#set zbronly [string first "ZBR" [$agent info class]] 
diff -Naur ns-allinone-2.35_orig/ns-2.35/tcl/lib/ns-packet.tcl ns-allinone-2.35/ns-2.35/tcl/lib/ns-packet.tcl
--- ns-allinone-2.35_orig/ns-2.35/tcl/lib/ns-packet.tcl	2020-07-24 19:47:50.897827918 +0300
+++ ns-allinone-2.35/ns-2.35/tcl/lib/ns-packet.tcl	2020-07-24 14:27:47.903033532 +0300
@@ -177,8 +177,9 @@
 	Smac 	# Sensor-MAC
 	TORA 	# routing protocol for ad-hoc networks
 	MDART 	# routing protocol for ad-hoc networks
-	# AOMDV patch
-	AOMDV
+	AOMDV   # AOMDV patch
+	PHR	#PHR routing protocol for VANETs
+	
 # Other:
 	Encap 	# common/encap.cc
         IPinIP 	# IP encapsulation 
diff -Naur ns-allinone-2.35_orig/ns-2.35/trace/cmu-trace.cc ns-allinone-2.35/ns-2.35/trace/cmu-trace.cc
--- ns-allinone-2.35_orig/ns-2.35/trace/cmu-trace.cc	2020-07-24 19:47:50.761824949 +0300
+++ ns-allinone-2.35/ns-2.35/trace/cmu-trace.cc	2020-07-24 14:24:12.924810603 +0300
@@ -61,6 +61,7 @@
 #include "wpan/p802_15_4pkt.h"
 #include "wpan/p802_15_4trace.h"
 #include "wpan/p802_15_4nam.h"
+#include <phr/phr_packet.h>
 //</zheng: add for 802.15.4>
 
 #include "diffusion/diff_header.h" // DIFFUSION -- Chalermek
@@ -1071,6 +1072,65 @@
 	}
 }
 
+/*PHR trace routine */
+void
+  CMUTrace::format_phr(Packet *p, int offset)
+        {
+            struct hdr_phr *phr = HDR_PHR(p);
+            struct hdr_phr_bc *bc = HDR_PHR_BC(p);
+
+            switch(phr->pkt_type) {
+
+                case PHR_BC:
+
+                    if (pt_->tagged()) {
+                        sprintf(pt_->buffer() + offset,
+                                  "-PHR:t %x -PHR:h %d -PHR:b %d -PHR:s %d "
+                                  "-PHR:ts %f "
+                                  "-PHR:c PHR ",
+                                  bc->bc_type,
+                                  bc->bc_hop_count,
+                                  bc->bc_bcast_id,
+                                  bc->bc_src,
+                                  bc->bc_timestamp);
+                    } else if (newtrace_) {
+
+                        sprintf(pt_->buffer() + offset,
+                                  "-P phr -Pt 0x%x -Ph %d -Pb %d -Ps %d -Pts %f -Pc PHR ",
+                                  bc->bc_type,
+                                  bc->bc_hop_count,
+                                  bc->bc_bcast_id,
+                                  bc->bc_src,
+                                  bc->bc_timestamp);
+
+		 } else {
+
+                        sprintf(pt_->buffer() + offset,
+                                  "[0x%x %d %d [%d] [%f]] (PHR)",
+                                  bc->bc_type,
+                                  bc->bc_hop_count,
+                                  bc->bc_bcast_id,
+                                  bc->bc_src,
+                                  bc->bc_timestamp);
+                    }
+                    break;
+
+
+                default:
+        #ifdef WIN32
+                    fprintf(stderr,
+                              "CMUTrace::format_phr: invalid PHR packet typen");
+        #else
+                    fprintf(stderr,
+                              "%s: invalid PHR packet typen", __FUNCTION__);
+        #endif
+                    abort();
+            }
+        }
+
+
+/*END of PHR trace routine */
+
 void
 CMUTrace::format_mdart(Packet *p, int offset)
 {
diff -Naur ns-allinone-2.35_orig/ns-2.35/trace/cmu-trace.h ns-allinone-2.35/ns-2.35/trace/cmu-trace.h
--- ns-allinone-2.35_orig/ns-2.35/trace/cmu-trace.h	2020-07-24 19:47:50.761824949 +0300
+++ ns-allinone-2.35/ns-2.35/trace/cmu-trace.h	2020-07-24 14:07:55.786685054 +0300
@@ -83,7 +83,8 @@
 #define DROP_RTR_QTIMEOUT               "TOUT"  // packet expired
 #define DROP_RTR_MAC_CALLBACK           "CBK"   // MAC callback
 #define DROP_RTR_SALVAGE	        "SAL"
-
+#define DROP_PHR_PH_CLOSER 		"CLOSER"//PH is closer to D
+#define DROP_PHR_DKNOW    		"DKNOW" // know flag set and don’tknow about D.
 #define DROP_IFQ_QFULL                  "IFQ"   // no buffer space in IFQ
 #define DROP_IFQ_ARP_FULL               "ARP"   // dropped by ARP
 #define DROP_IFQ_FILTER                 "FIL"
@@ -161,6 +162,7 @@
         void    format_aodv(Packet *p, int offset);
 	void    format_aomdv(Packet *p, int offset);
 	void    format_mdart(Packet *p, int offset);
+	void	format_phr(Packet *p, int offset);
 
 	// This holds all the tracers added at run-time
 	static PacketTracer *pktTrc_;
